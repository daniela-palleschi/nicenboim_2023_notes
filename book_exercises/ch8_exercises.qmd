---
title: "Ch. 8 Exercises"
---

```{r}
pacman::p_load(
  tidyverse,
  brms,
  here,
  Rmisc
)
summarise <- dplyr::summarise
```

## **Exercise 8.1** Contrast coding for a four-condition design

> Load the following data. These data are from Experiment 1 in a set of reading studies on Persian (Safavi, Husain, and Vasishth 2016). This is a self-paced reading study on particle-verb constructions, with a  2 x 2 design: distance (short, long) and predictability (predictable, unpredictable). The data are from a critical region in the sentence. All the data from the Safavi, Husain, and Vasishth (2016) paper are available from https://github.com/vasishth/SafaviEtAl2016.

```{r}
library(bcogsci)
data("df_persianE1")
dat1 <- df_persianE1
head(dat1)
```

> The four conditions are:
>
- Distance=short and Predictability=unpredictable
- Distance=short and Predictability=predictable
- Distance=long and Predictability=unpredictable
- Distance=long and Predictability=predictable
>
> The researcher wants to do the following sets of comparisons between condition means:
>
> Compare the condition labeled Distance=short and Predictability=unpredictable with each of the following conditions:
> 
- Distance=short and Predictability=predictable
- Distance=long and Predictability=unpredictable
- Distance=long and Predictability=predictable

### Questions

> 1. Which contrast coding is needed for such a comparison?

Treatment contrasts, because we're comparing everything to on baseline condition.

```{r}
dat1$distance <- as.factor(dat1$distance)
dat1$predability <- as.factor(dat1$predability)
```

```{r}
levels(dat1$distance)
levels(dat1$predability)
```

Each have 2 levels (2x2 design).

Desired comparisons:

- short-unpredictable vs. short-predictable
- short-unpredictable vs. long-predictable
- short-unpredictable vs. long-unpredictable

- we do *not* care about comparing short and unpredictable
- so we want treatment contrasts, with short-predictable as our baseline


> 2. First, define the relevant contrast coding. Hint: You can do it by creating a condition column labeled a,b,c,d and then use a built-in contrast coding function.

Create variable 'cond'

```{r}
dat1 <- dat1 |> 
  mutate(cond = paste(distance, predability, sep = "-"),
         cond = fct_relevel(cond, "short-unpredictable", "short-predictable"))
```

Set treatment contrasts

```{r}
dat1$cond <- as.factor(dat1$cond)
contrasts(dat1$cond) <- contr.treatment(4)
```

Print contrast matrix

```{r}
contrasts(dat1$cond)
```

So cond1 will be a comparisons between short-unpred and long-pred, etc.

Let's also look at the means per condition.

```{r}
dat1 |> 
  Rmisc::summarySEwithin(
    measurevar = "rt", withinvars = c("distance", "predability")
  ) |> 
  knitr::kable()
```


> 3. Then, use the hypr library function to confirm that your contrast coding actually does the comparison you need.

We'll need to define our 3 comparisons:

```{r}
library(hypr)
```


```{r}
levels(dat1$cond)
```


```{r}
cond_treat <-
  hypr(
   b0 = `short-unpredictable` ~ 0, # include intercept
   b1 = `long-predictable` ~ `short-unpredictable`,
   b2 = `long-unpredictable` ~ `short-unpredictable`,
   b3 = `short-predictable` ~ `short-unpredictable`,
   levels = c("short-unpredictable", "short-predictable", "long-predictable", "long-unpredictable")
 )

cond_treat
```

Check out hypothesis matrix

```{r}
contr.hypothesis(cond_treat)
```


Set contrasts.

```{r}
contrasts(dat1$cond) <- contr.hypothesis(cond_treat)
```

Print contrasts

```{r}
contrasts(dat1$cond)
```


> 4. Fit a simple linear model with the above contrast coding and display the slopes, which constitute the relevant comparisons.

```{r}
fit_dat1 <- brm(rt ~ 1 + cond,
  data = dat1,
  family = gaussian(),
  # prior = c(
  #   prior(normal(550, 25), class = Intercept),
  #   prior(normal(25, 2), class = sigma),
  #   prior(normal(25, 1), class = b)
  # ),
  file = here::here("models/exercises/ch8/fit_ch_8_ex1")
)
```

```{r}
fixef(fit_dat1)
```

Calculate the estimates per condition:

```{r}
# intercept
short_unpred <- fixef(fit_dat1)[1,"Estimate"]
long_pred <- short_unpred + fixef(fit_dat1)[2,"Estimate"]
long_unpred <- short_unpred + fixef(fit_dat1)[3,"Estimate"]
short_pred <- short_unpred + fixef(fit_dat1)[4,"Estimate"]

```

```{r}
short_unpred
long_pred
long_unpred
short_pred
```


```{r}
contrasts(dat1$cond)
```


> 5. Now, compute each of the four conditionsâ€™ means and check that the slopes from the linear model correspond to the relevant differences between means that you obtained from the data.

```{r}
dat1 |> 
  Rmisc::summarySEwithin(
    measurevar = "rt", withinvars = c("distance", "predability")
  ) |> 
  knitr::kable()
```

Or with the tidyverse:

```{r}
dat1 |> 
  dplyr::summarise(mean = mean(rt),
            .by = cond)
```

Yup they correspond.

## **Exercise 8.2** Helmert coding for a four-condition design.

> Load the following data:
>
```{r}
library(bcogsci)
data("df_polarity")
head(df_polarity)
```

> The data come from an eyetracking study in German reported in Vasishth et al. (2008). The experiment is a reading study involving six conditions. The sentences are in English, but the original design was involved German sentences. In German, the word durchaus (certainly) is a positive polarity item: in the constructions used in this experiment, durchaus cannot have a c-commanding element that is a negative polarity item licensor. Here are the conditions:
> 
- Negative polarity items
    a. Grammatical: No man who had a beard was ever thrifty.
    b. Ungrammatical (Intrusive NPI licensor): A man who had no beard was ever thrifty.
    c. Ungrammatical: A man who had a beard was ever thrifty.
- Positive polarity items
    e. Ungrammatical: No man who had a beard was certainly thrifty.
    f. Grammatical (Intrusive NPI licensor): A man who had no beard was certainly thrifty.
    g. Grammatical: A man who had a beard was certainly thrifty.
>
We will focus only on re-reading time in this data set. Subset the data so that we only have re-reading times in the data frame:

```{r}
dat2 <- subset(df_polarity, times == "RRT")
head(dat2)
```

The comparisons we are interested in are:
>
- RQ1: What is the difference in reading time between negative polarity items and positive polarity items?
- RQ2: Within negative polarity items, what is the difference between grammatical and ungrammatical conditions?
- RQ3: Within negative polarity items, what is the difference between the two ungrammatical conditions?
- RQ4: Within positive polarity items, what is the difference between grammatical and ungrammatical conditions?
- RQ5: Within positive polarity items, what is the difference between the two grammatical conditions?
>
Use the `hypr` package to specify the comparisons specified above, and then extract the contrast matrix. 

My outline of our effects/comparisons of interest:

- a main effect of polarity (positive vs negative)
- nested effect of grammaticality within either level of polarity
- effect of intrusivity within either polarity level

```{r}
levels(dat2$condition)
```

To help me: create predictor factors.

```{r}
dat2 <-
  dat2 |> 
  mutate(polarity = ifelse(condition %in% c("a", "b", "c"), "negative", "positive"),
         gramm = ifelse(condition %in% c("a", "e", "f"), "gramm", "ungramm"),
         intru = ifelse(condition %in% c("b", "e"), "intrusive", "unintrusive"))
```

```{r}
dat2 |> 
  distinct(condition, .keep_all = T) |> 
  arrange(condition)
```


```{r}
cond_dat2 <-
  hypr(
   rq1 =  (a + b + c) /3~ (d + e + f) /3,
   rq2 = a ~ (b + c) / 2,
   rq3 = b ~ c,
   rq4 = d ~ (e+f)/2,
   rq5 = e ~ f,
   levels = c("a", "b", "c", "d", "e", "f")
 )

cond_dat2
```

> Finally, specify the contrasts to the condition column in the data frame. 


```{r}
contrasts(dat2$condition) <- contr.hypothesis(cond_dat2)
```

```{r}
contrasts(dat2$condition)
```

> Fit a linear model using this contrast specification, and then check that the estimates from the model match the mean differences between the conditions being compared.

```{r}
fit_dat2 <- brm(value ~ 1 + condition,
  data = dat2,
  family = gaussian(),
  # prior = c(
  #   prior(normal(550, 25), class = Intercept),
  #   prior(normal(25, 2), class = sigma),
  #   prior(normal(25, 1), class = b)
  # ),
  file = here::here("models/exercises/ch8/fit_ch_8_ex2")
)
```

```{r}
fixef(fit_dat2)
```

Calculate the estimates per condition:

```{r}
contrasts(dat2$condition)
```


```{r}
# intercept
intercept <- fixef(fit_dat2)["Intercept","Estimate"]
```

### RQ1: dif between positive and negative

Raw diff's.

```{r}
dat2 |> 
  summarise(mean = mean(value),
            .by = polarity) |> 
  pivot_wider(names_from = polarity, values_from = mean) |> 
  mutate(difference = negative - positive)
```


```{r}
positive <- intercept + fixef(fit_dat2)["conditionrq1","Estimate"]*-0.5
negative <- intercept + fixef(fit_dat2)["conditionrq1","Estimate"]*0.5
rq1 <- negative - positive
```

Estimated diff.

```{r}
rq1
```

Slope value.

```{r}
fixef(fit_dat2)["conditionrq1","Estimate"]
```



### RQ2: Grammaticality diff's within negative (cond a vs b+c)

Raw diff's.

```{r}
dat2 |> 
  filter(polarity == "negative") |> 
  summarise(mean = mean(value),
            .by = gramm) |> 
  pivot_wider(names_from = gramm, values_from = mean) |> 
  mutate(difference = gramm - ungramm)
```


```{r}
est_gramm <- intercept + fixef(fit_dat2)["conditionrq2","Estimate"]*0.5
est_ungramm <- intercept + fixef(fit_dat2)["conditionrq2","Estimate"]*-0.5
rq2 <- est_gramm - est_ungramm
```

Estimated diff.

```{r}
rq2
```

Slope value.

```{r}
fixef(fit_dat2)["conditionrq2","Estimate"]
```

### RQ3: Ungramm vs. ungramm within negative (cond b vs. c)

Raw diff's.

```{r}
dat2 |> 
  summarise(mean = mean(value),
            .by = condition) |> 
  filter(condition %in% c("b", "c")) |> 
  pivot_wider(names_from = condition, values_from = mean) |> 
  mutate(difference = b - c)
```


```{r}
est_b <- intercept + fixef(fit_dat2)["conditionrq3","Estimate"]*0.5
est_c <- intercept + fixef(fit_dat2)["conditionrq3","Estimate"]*-0.5
rq3 <- est_b - est_c
```

Estimated diff.

```{r}
rq3
```

Slope value.

```{r}
fixef(fit_dat2)["conditionrq3","Estimate"]
```

### RQ4: Grammaticality diff's within positive (cond d vs. e + f)


Raw diff's.

```{r}
dat2 |> 
  filter(polarity == "positive") |> 
  summarise(mean = mean(value),
            .by = gramm) |> 
  pivot_wider(names_from = gramm, values_from = mean) |> 
  mutate(difference = gramm - ungramm)
```


```{r}
est_gramm <- intercept + fixef(fit_dat2)["conditionrq4","Estimate"]*0.5
est_ungramm <- intercept + fixef(fit_dat2)["conditionrq4","Estimate"]*-0.5
rq4 <- est_gramm - est_ungramm
```

Estimated diff.

```{r}
rq4
```

Slope value.

```{r}
fixef(fit_dat2)["conditionrq4","Estimate"]
```

### RQ5: Gramm vs. gramm within positive (cond e vs. f)

Raw diff's.

```{r}
dat2 |> 
  summarise(mean = mean(value),
            .by = condition) |> 
  filter(condition %in% c("e", "f")) |> 
  pivot_wider(names_from = condition, values_from = mean) |> 
  mutate(difference = e - f)
```


```{r}
est_e <- intercept + fixef(fit_dat2)["conditionrq5","Estimate"]*0.5
est_f <- intercept + fixef(fit_dat2)["conditionrq5","Estimate"]*-0.5
rq5 <- est_e - est_f
```

Estimated diff.

```{r}
rq5
```

Slope value.

```{r}
fixef(fit_dat2)["conditionrq5","Estimate"]
```


## **Exercise 8.3** Number of possible comparisons in a single model.

> How many comparisons can one make in a single model when there is a single factor with four levels? Why can we not code four comparisons in a single model?

1 v (2,3,4)
(1,2) v. (3,4)
(1,2,3) v. 4
1 v 2
1 v 3
1 v 4

3 v. (3)

> How many comparisons can one code in a model where there are two factors, one with three levels and one with two levels?

Six conditions, two main effects.

> How about a model for a  2 x 2 design?

Four conditions, two main effects.
- compare main effects (x1)
- compare nested effects for pred1/pred2 (x2)
  + and pred2/pred1 (x2)
  
# Session Info

Compiled with `r R.version$version` (`r R.version$nickname`) in RStudio version 2023.12.1.402 (Ocean Storm).

```{r}
#| eval: false
#| echo: false
RStudio.Version()$version; RStudio.Version()$release_name
```

```{r}
sessionInfo()
```

# References {.unnumbered}

::: {#refs custom-style="Bibliography"}
:::